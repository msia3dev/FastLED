#pragma once
#include <SPI.h>

#ifndef FASTLED_INTERNAL
  #pragma message "NOTE: Using SPI DMA to drive LED strip!"
#endif

FASTLED_NAMESPACE_BEGIN

#define FASTLED_HAS_CLOCKLESS 1

#if F_CPU == 72000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV32 // 444ns
#elif F_CPU == 64000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV32 // 500ns
#elif F_CPU == 48000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV16 // 333ns
#elif F_CPU == 40000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV16 // 400ns
#elif F_CPU == 36000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV16 // 444ns
#elif F_CPU == 24000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV8 // 333ns
#elif F_CPU == 16000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV8 // 500ns
#elif F_CPU == 8000000L
  #define WS2812B_SPI_DIVISOR SPI_CLOCK_DIV4 // 500ns
#else
  #error No clock divisor available for this F_CPU
#endif

// New version uses one large LUT as its faster index into sequential bytes for the GRB pattern
static const uint8_t encoderLookup[256*3]={	0x92,0x49,0x24,0x92,0x49,0x26,0x92,0x49,0x34,0x92,0x49,0x36,0x92,0x49,0xA4,0x92,0x49,0xA6,0x92,0x49,0xB4,0x92,0x49,0xB6,0x92,0x4D,0x24,0x92,0x4D,0x26,0x92,0x4D,0x34,0x92,0x4D,0x36,0x92,0x4D,0xA4,0x92,0x4D,0xA6,0x92,0x4D,0xB4,0x92,0x4D,0xB6,0x92,0x69,0x24,0x92,0x69,0x26,0x92,0x69,0x34,0x92,0x69,0x36,0x92,0x69,0xA4,0x92,0x69,0xA6,0x92,0x69,0xB4,0x92,0x69,0xB6,0x92,0x6D,0x24,0x92,0x6D,0x26,0x92,0x6D,0x34,0x92,0x6D,0x36,0x92,0x6D,0xA4,0x92,0x6D,0xA6,0x92,0x6D,0xB4,0x92,0x6D,0xB6,0x93,0x49,0x24,0x93,0x49,0x26,0x93,0x49,0x34,0x93,0x49,0x36,0x93,0x49,0xA4,0x93,0x49,0xA6,0x93,0x49,0xB4,0x93,0x49,0xB6,0x93,0x4D,0x24,0x93,0x4D,0x26,0x93,0x4D,0x34,0x93,0x4D,0x36,0x93,0x4D,0xA4,0x93,0x4D,0xA6,0x93,0x4D,0xB4,0x93,0x4D,0xB6,0x93,0x69,0x24,0x93,0x69,0x26,0x93,0x69,0x34,0x93,0x69,0x36,0x93,0x69,0xA4,0x93,0x69,0xA6,0x93,0x69,0xB4,0x93,0x69,0xB6,0x93,0x6D,0x24,0x93,0x6D,0x26,0x93,0x6D,0x34,0x93,0x6D,0x36,0x93,0x6D,0xA4,0x93,0x6D,0xA6,0x93,0x6D,0xB4,0x93,0x6D,0xB6,0x9A,0x49,0x24,0x9A,0x49,0x26,0x9A,0x49,0x34,0x9A,0x49,0x36,0x9A,0x49,0xA4,0x9A,0x49,0xA6,0x9A,0x49,0xB4,0x9A,0x49,0xB6,0x9A,0x4D,0x24,0x9A,0x4D,0x26,0x9A,0x4D,0x34,0x9A,0x4D,0x36,0x9A,0x4D,0xA4,0x9A,0x4D,0xA6,0x9A,0x4D,0xB4,0x9A,0x4D,0xB6,0x9A,0x69,0x24,0x9A,0x69,0x26,0x9A,0x69,0x34,0x9A,0x69,0x36,0x9A,0x69,0xA4,0x9A,0x69,\
											0xA6,0x9A,0x69,0xB4,0x9A,0x69,0xB6,0x9A,0x6D,0x24,0x9A,0x6D,0x26,0x9A,0x6D,0x34,0x9A,0x6D,0x36,0x9A,0x6D,0xA4,0x9A,0x6D,0xA6,0x9A,0x6D,0xB4,0x9A,0x6D,0xB6,0x9B,0x49,0x24,0x9B,0x49,0x26,0x9B,0x49,0x34,0x9B,0x49,0x36,0x9B,0x49,0xA4,0x9B,0x49,0xA6,0x9B,0x49,0xB4,0x9B,0x49,0xB6,0x9B,0x4D,0x24,0x9B,0x4D,0x26,0x9B,0x4D,0x34,0x9B,0x4D,0x36,0x9B,0x4D,0xA4,0x9B,0x4D,0xA6,0x9B,0x4D,0xB4,0x9B,0x4D,0xB6,0x9B,0x69,0x24,0x9B,0x69,0x26,0x9B,0x69,0x34,0x9B,0x69,0x36,0x9B,0x69,0xA4,0x9B,0x69,0xA6,0x9B,0x69,0xB4,0x9B,0x69,0xB6,0x9B,0x6D,0x24,0x9B,0x6D,0x26,0x9B,0x6D,0x34,0x9B,0x6D,0x36,0x9B,0x6D,0xA4,0x9B,0x6D,0xA6,0x9B,0x6D,0xB4,0x9B,0x6D,0xB6,0xD2,0x49,0x24,0xD2,0x49,0x26,0xD2,0x49,0x34,0xD2,0x49,0x36,0xD2,0x49,0xA4,0xD2,0x49,0xA6,0xD2,0x49,0xB4,0xD2,0x49,0xB6,0xD2,0x4D,0x24,0xD2,0x4D,0x26,0xD2,0x4D,0x34,0xD2,0x4D,0x36,0xD2,0x4D,0xA4,0xD2,0x4D,0xA6,0xD2,0x4D,0xB4,0xD2,0x4D,0xB6,0xD2,0x69,0x24,0xD2,0x69,0x26,0xD2,0x69,0x34,0xD2,0x69,0x36,0xD2,0x69,0xA4,0xD2,0x69,0xA6,0xD2,0x69,0xB4,0xD2,0x69,0xB6,0xD2,0x6D,0x24,0xD2,0x6D,0x26,0xD2,0x6D,0x34,0xD2,0x6D,0x36,0xD2,0x6D,0xA4,0xD2,0x6D,0xA6,0xD2,0x6D,0xB4,0xD2,0x6D,0xB6,0xD3,0x49,0x24,0xD3,0x49,0x26,0xD3,0x49,0x34,0xD3,0x49,0x36,0xD3,0x49,0xA4,0xD3,0x49,0xA6,0xD3,0x49,0xB4,0xD3,0x49,0xB6,0xD3,0x4D,0x24,0xD3,0x4D,0x26,0xD3,0x4D,0x34,0xD3,\
											0x4D,0x36,0xD3,0x4D,0xA4,0xD3,0x4D,0xA6,0xD3,0x4D,0xB4,0xD3,0x4D,0xB6,0xD3,0x69,0x24,0xD3,0x69,0x26,0xD3,0x69,0x34,0xD3,0x69,0x36,0xD3,0x69,0xA4,0xD3,0x69,0xA6,0xD3,0x69,0xB4,0xD3,0x69,0xB6,0xD3,0x6D,0x24,0xD3,0x6D,0x26,0xD3,0x6D,0x34,0xD3,0x6D,0x36,0xD3,0x6D,0xA4,0xD3,0x6D,0xA6,0xD3,0x6D,0xB4,0xD3,0x6D,0xB6,0xDA,0x49,0x24,0xDA,0x49,0x26,0xDA,0x49,0x34,0xDA,0x49,0x36,0xDA,0x49,0xA4,0xDA,0x49,0xA6,0xDA,0x49,0xB4,0xDA,0x49,0xB6,0xDA,0x4D,0x24,0xDA,0x4D,0x26,0xDA,0x4D,0x34,0xDA,0x4D,0x36,0xDA,0x4D,0xA4,0xDA,0x4D,0xA6,0xDA,0x4D,0xB4,0xDA,0x4D,0xB6,0xDA,0x69,0x24,0xDA,0x69,0x26,0xDA,0x69,0x34,0xDA,0x69,0x36,0xDA,0x69,0xA4,0xDA,0x69,0xA6,0xDA,0x69,0xB4,0xDA,0x69,0xB6,0xDA,0x6D,0x24,0xDA,0x6D,0x26,0xDA,0x6D,0x34,0xDA,0x6D,0x36,0xDA,0x6D,0xA4,0xDA,0x6D,0xA6,0xDA,0x6D,0xB4,0xDA,0x6D,0xB6,0xDB,0x49,0x24,0xDB,0x49,0x26,0xDB,0x49,0x34,0xDB,0x49,0x36,0xDB,0x49,0xA4,0xDB,0x49,0xA6,0xDB,0x49,0xB4,0xDB,0x49,0xB6,0xDB,0x4D,0x24,0xDB,0x4D,0x26,0xDB,0x4D,0x34,0xDB,0x4D,0x36,0xDB,0x4D,0xA4,0xDB,0x4D,0xA6,0xDB,0x4D,0xB4,0xDB,0x4D,0xB6,0xDB,0x69,0x24,0xDB,0x69,0x26,0xDB,0x69,0x34,0xDB,0x69,0x36,0xDB,0x69,0xA4,0xDB,0x69,0xA6,0xDB,0x69,0xB4,0xDB,0x69,0xB6,0xDB,0x6D,0x24,0xDB,0x6D,0x26,0xDB,0x6D,0x34,0xDB,0x6D,0x36,0xDB,0x6D,0xA4,0xDB,0x6D,0xA6,0xDB,0x6D,0xB4,0xDB,0x6D,0xB6};

template <int DATA_PIN, int T1, int T2, int T3, EOrder RGB_ORDER = RGB, int XTRA0 = 0, bool FLIP = false, int WAIT_TIME = 50>
class ClocklessController : public CPixelLEDController<RGB_ORDER> {

uint16_t
    numBytes;      // Size of 'm_pixels' buffer

bool
    loadNum  = true;

uint8_t
   *m_pixels,        // Holds the current LED color values, which the external API calls interact with 9 bytes per pixel + start + end empty bytes
   *doubleBuffer;	// Holds the start of the double buffer (1 buffer for async DMA transfer and one for the API interaction.
public:
    virtual void init() {
        SPI.setClockDivider(WS2812B_SPI_DIVISOR);
        SPI.begin();
    }

protected:
    virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
        if (this->loadNum){
            this->updateLength(this->m_nLeds);
            this->loadNum = false;
        }

        this->prepareBuffer(pixels);
        SPI.dmaSendAsync(m_pixels,numBytes);// Start the DMA transfer of the current pixel buffer to the LEDs and return immediately.

        // Need to copy the last / current buffer to the other half of the double buffer as most API code does not rebuild the entire contents
        // from scratch. Often just a few m_pixels are changed e.g in a chaser effect
        
        if (m_pixels == doubleBuffer){
            // m_pixels was using the first buffer
            m_pixels	= doubleBuffer+numBytes;  // set m_pixels to second buffer
            memcpy(m_pixels,doubleBuffer,numBytes);// copy first buffer to second buffer
        } else {
            // m_pixels was using the second buffer	  
            m_pixels	= doubleBuffer;  // set m_pixels to first buffer
            memcpy(m_pixels,doubleBuffer+numBytes,numBytes);	 // copy second buffer to first buffer 
        }
    }

private:

    void prepareBuffer(PixelController<RGB_ORDER> & m_pixels) {
        uint8_t r, g, b;
        uint16_t i = 0;
        // Setup the pixel controller and load/scale the first byte
        m_pixels.preStepFirstByteDithering();
        // WS2812B expects data in GRB order, so this is how it's stored in buffer
        g = m_pixels.loadAndScale0();
        while(m_pixels.has(1)) {
            m_pixels.stepDithering();
            r = m_pixels.loadAndScale1();
            b = m_pixels.loadAndScale2();
            this->setPixelColor(i++, r, g, b);
            r = m_pixels.advanceAndLoadAndScale0();
        }
    }

    void updateLength(uint16_t n) {
        if(doubleBuffer)
            free(doubleBuffer); 

        numBytes = (n<<3) + n + 2; // 9 encoded bytes per pixel. 1 byte empty peamble to fix issue with SPI MOSI and on byte at the end to clear down MOSI 
							// Note. (n<<3) +n is a fast way of doing n*9
        if ((doubleBuffer = (uint8_t *)malloc(numBytes*2))) {
	        m_pixels = doubleBuffer; // Only need to init the part of the double buffer which will be interacted with by the API e.g. setPixelColor
	        *m_pixels=0; //clear the preamble byte
	        *(m_pixels+numBytes-1)=0; // clear the post send cleardown byte.
	        clear(); // Set the encoded data to all encoded zeros 
        } else {
            numBytes = 0;
        }
    }

    /*
     * Sets a specific pixel to a specific r,g,b colour 
     * Because the m_pixels buffer contains the encoded bitstream, which is in triplets
     * the lookup table need to be used to find the correct pattern for each byte in the 3 byte sequence.
     */
    void setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
        uint8_t *bptr = m_pixels + (n<<3) + n +1;
        uint8_t *tPtr = (uint8_t *)encoderLookup + g*2 + g; // need to index 3 x g into the lookup
        
        *bptr++ = *tPtr++;
        *bptr++ = *tPtr++;
        *bptr++ = *tPtr++;

        tPtr = (uint8_t *)encoderLookup + r*2 + r;
        *bptr++ = *tPtr++;
        *bptr++ = *tPtr++;
        *bptr++ = *tPtr++;   
        
        tPtr = (uint8_t *)encoderLookup + b*2 + b;
        *bptr++ = *tPtr++;
        *bptr++ = *tPtr++;
        *bptr++ = *tPtr++;
    }

    /*
     * Sets the encoded pixel data to turn all the LEDs off.
     */
    void clear() {
        uint8_t * bptr= m_pixels+1; // Note first byte in the buffer is a preable and is always zero. hence the +1
        uint8_t *tPtr;

        for(int i=0;i< (this->m_nLeds *3);i++){
            tPtr = (uint8_t *)encoderLookup;
            *bptr++ = *tPtr++;
            *bptr++ = *tPtr++;
            *bptr++ = *tPtr++;
        }
    }
};